"""Agent Bricks tools - Manage Knowledge Assistants (KA) and Multi-Agent Supervisors (MAS).

For Genie Space tools, see genie.py
"""

from typing import Any, Dict, List, Optional

from databricks_tools_core.agent_bricks import (
    AgentBricksManager,
    EndpointStatus,
    get_tile_example_queue,
)

from ..manifest import register_deleter
from ..server import mcp

# Singleton manager instance
_manager: Optional[AgentBricksManager] = None


def _get_manager() -> AgentBricksManager:
    """Get or create the singleton AgentBricksManager instance."""
    global _manager
    if _manager is None:
        _manager = AgentBricksManager()
    return _manager


def _delete_ka_resource(resource_id: str) -> None:
    _get_manager().delete(resource_id)


def _delete_mas_resource(resource_id: str) -> None:
    _get_manager().delete(resource_id)


register_deleter("knowledge_assistant", _delete_ka_resource)
register_deleter("multi_agent_supervisor", _delete_mas_resource)


# ============================================================================
# Knowledge Assistant (KA) Tools
# ============================================================================


@mcp.tool
def create_or_update_ka(
    name: str,
    volume_path: str,
    description: str = None,
    instructions: str = None,
    tile_id: str = None,
    add_examples_from_volume: bool = True,
) -> Dict[str, Any]:
    """
    Create or update a Knowledge Assistant (KA) with document knowledge sources.

    A Knowledge Assistant is a document-based Q&A system that uses RAG to answer
    questions from indexed documents (PDFs, text files, etc.).

    Args:
        name: Name for the KA (will be sanitized for Databricks naming rules)
        volume_path: Path to the volume folder containing documents
            (e.g., "/Volumes/catalog/schema/volume/folder")
        description: Optional description of what the KA does
        instructions: Optional instructions for how the KA should answer
        tile_id: Optional existing tile_id to update instead of create
        add_examples_from_volume: If True, scan the volume for JSON files
            containing question/guideline pairs and add them as examples.
            These are typically generated by the PDF generation tool.

    Returns:
        Dictionary with:
        - tile_id: The KA tile ID
        - name: The KA name
        - operation: 'created' or 'updated'
        - endpoint_status: Current endpoint status
        - examples_queued: Number of examples queued (if any)

    Example:
        >>> create_or_update_ka(
        ...     name="HR Policy Assistant",
        ...     volume_path="/Volumes/my_catalog/my_schema/raw_data/hr_docs",
        ...     description="Answers questions about HR policies",
        ...     instructions="Be helpful and cite specific policies when answering"
        ... )
        {
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "operation": "created",
            "endpoint_status": "PROVISIONING",
            "examples_queued": 5
        }
    """
    manager = _get_manager()

    # Build knowledge source from volume path
    knowledge_sources = [
        {
            "files_source": {
                "name": f"source_{name.replace(' ', '_').lower()}",
                "type": "files",
                "files": {"path": volume_path},
            }
        }
    ]

    # Create or update the KA
    result = manager.ka_create_or_update(
        name=name,
        knowledge_sources=knowledge_sources,
        description=description,
        instructions=instructions,
        tile_id=tile_id,
    )

    # Extract tile info
    ka_data = result.get("knowledge_assistant", {})
    tile_data = ka_data.get("tile", {})
    status_data = ka_data.get("status", {})

    response_tile_id = tile_data.get("tile_id", "")
    endpoint_status = status_data.get("endpoint_status", "UNKNOWN")

    response = {
        "tile_id": response_tile_id,
        "name": tile_data.get("name", name),
        "operation": result.get("operation", "created"),
        "endpoint_status": endpoint_status,
        "examples_queued": 0,
    }

    # Scan volume for examples if requested
    if add_examples_from_volume and response_tile_id:
        examples = manager.scan_volume_for_examples(volume_path)
        if examples:
            # If endpoint is ONLINE, add examples directly
            if endpoint_status == EndpointStatus.ONLINE.value:
                created = manager.ka_add_examples_batch(response_tile_id, examples)
                response["examples_added"] = len(created)
            else:
                # Queue examples for when endpoint becomes ready
                queue = get_tile_example_queue()
                queue.enqueue(response_tile_id, manager, examples, tile_type="KA")
                response["examples_queued"] = len(examples)

    # Track resource on successful create/update
    try:
        if response_tile_id:
            from ..manifest import track_resource

            track_resource(
                resource_type="knowledge_assistant",
                name=response.get("name", name),
                resource_id=response_tile_id,
            )
    except Exception:
        pass  # best-effort tracking

    return response


@mcp.tool
def get_ka(tile_id: str) -> Dict[str, Any]:
    """
    Get a Knowledge Assistant by tile ID.

    Args:
        tile_id: The KA tile ID

    Returns:
        Dictionary with KA details including:
        - tile_id: The tile ID
        - name: The KA name
        - description: The description
        - endpoint_status: Current status (ONLINE, PROVISIONING, etc.)
        - knowledge_sources: List of configured sources
        - examples_count: Number of example questions

    Example:
        >>> get_ka("01abc...")
        {
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "endpoint_status": "ONLINE",
            "knowledge_sources": [...],
            "examples_count": 5
        }
    """
    manager = _get_manager()
    result = manager.ka_get(tile_id)

    if not result:
        return {"error": f"Knowledge Assistant {tile_id} not found"}

    ka_data = result.get("knowledge_assistant", {})
    tile_data = ka_data.get("tile", {})
    status_data = ka_data.get("status", {})

    # Get examples count
    examples_response = manager.ka_list_examples(tile_id)
    examples_count = len(examples_response.get("examples", []))

    return {
        "tile_id": tile_data.get("tile_id", tile_id),
        "name": tile_data.get("name", ""),
        "description": tile_data.get("description", ""),
        "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
        "knowledge_sources": ka_data.get("knowledge_sources", []),
        "examples_count": examples_count,
        "instructions": ka_data.get("instructions", ""),
    }


@mcp.tool
def find_ka_by_name(name: str) -> Dict[str, Any]:
    """
    Find a Knowledge Assistant by its name.

    Use this to look up a KA when you know the name but not the tile_id.
    This is useful when referencing an existing KA in a Multi-Agent Supervisor.

    Args:
        name: The name of the Knowledge Assistant to find (exact match)

    Returns:
        Dictionary with:
        - found: True if a matching KA was found
        - tile_id: The tile ID (if found)
        - name: The KA name (if found)
        - endpoint_name: The model serving endpoint name (if found)
        - endpoint_status: Current status (if found)

    Example:
        >>> find_ka_by_name("HR_Policy_Assistant")
        {
            "found": True,
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "endpoint_name": "ka-01abc...-endpoint",
            "endpoint_status": "ONLINE"
        }
    """
    manager = _get_manager()
    result = manager.find_by_name(name)

    if result is None:
        return {"found": False, "name": name}

    # Fetch full details to get endpoint status
    full_details = manager.ka_get(result.tile_id)
    endpoint_status = "UNKNOWN"
    if full_details:
        endpoint_status = (
            full_details.get("knowledge_assistant", {}).get("status", {}).get("endpoint_status", "UNKNOWN")
        )

    # Endpoint name uses only the first segment of the tile_id (before the first hyphen)
    tile_id_prefix = result.tile_id.split("-")[0]
    return {
        "found": True,
        "tile_id": result.tile_id,
        "name": result.name,
        "endpoint_name": f"ka-{tile_id_prefix}-endpoint",
        "endpoint_status": endpoint_status,
    }


@mcp.tool
def delete_ka(tile_id: str) -> Dict[str, Any]:
    """
    Delete a Knowledge Assistant.

    Args:
        tile_id: The KA tile ID to delete

    Returns:
        Dictionary with:
        - success: True if deleted
        - tile_id: The deleted tile ID

    Example:
        >>> delete_ka("01abc...")
        {"success": True, "tile_id": "01abc..."}
    """
    manager = _get_manager()
    try:
        manager.delete(tile_id)
        try:
            from ..manifest import remove_resource

            remove_resource(resource_type="knowledge_assistant", resource_id=tile_id)
        except Exception:
            pass
        return {"success": True, "tile_id": tile_id}
    except Exception as e:
        return {"success": False, "tile_id": tile_id, "error": str(e)}


# ============================================================================
# Multi-Agent Supervisor (MAS) Tools
# ============================================================================


@mcp.tool
def create_or_update_mas(
    name: str,
    agents: List[Dict[str, str]],
    description: str = None,
    instructions: str = None,
    tile_id: str = None,
    examples: List[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Create or update a Multi-Agent Supervisor (MAS).

    A MAS orchestrates multiple agents, routing user queries to the appropriate
    specialized agent based on the query content. Supports both model serving
    endpoints and Genie spaces as agents.

    Args:
        name: Name for the MAS (will be sanitized for Databricks naming rules)
        agents: List of agent configurations. Each agent requires:
            - name: Agent identifier (used internally for routing)
            - description: What this agent handles (critical for routing decisions)
            - endpoint_name: Model serving endpoint name (for custom agents)
            - genie_space_id: Genie space ID (for SQL-based data agents)
            - ka_tile_id: Knowledge Assistant tile ID (for document Q&A agents)
            Note: Provide exactly one of: endpoint_name, genie_space_id, or ka_tile_id.
        description: Optional description of what the MAS does
        instructions: Optional routing instructions for the supervisor
        tile_id: Optional existing tile_id to update instead of create
        examples: Optional list of example questions, each with:
            - question: The example question
            - guideline: Expected routing behavior or answer guidelines

    Returns:
        Dictionary with:
        - tile_id: The MAS tile ID
        - name: The MAS name
        - operation: 'created' or 'updated'
        - endpoint_status: Current endpoint status
        - agents_count: Number of configured agents

    Example:
        >>> # Mix of Knowledge Assistants, Genie spaces, and custom endpoints
        >>> create_or_update_mas(
        ...     name="Customer Support MAS",
        ...     agents=[
        ...         {
        ...             "name": "policy_agent",
        ...             "ka_tile_id": "f32c5f73-466b-...",
        ...             "description": "Answers questions about company policies and procedures"
        ...         },
        ...         {
        ...             "name": "analytics_agent",
        ...             "genie_space_id": "01abc123...",
        ...             "description": "Answers data questions about usage and metrics"
        ...         },
        ...         {
        ...             "name": "custom_agent",
        ...             "endpoint_name": "my-custom-endpoint",
        ...             "description": "Handles specialized queries via custom agent"
        ...         }
        ...     ],
        ...     description="Routes customer queries to specialized agents",
        ...     instructions="Route policy questions to policy_agent, data questions to analytics_agent."
        ... )
        {
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "operation": "created",
            "endpoint_status": "PROVISIONING",
            "agents_count": 3
        }
    """
    manager = _get_manager()

    # Validate and build agent list for API
    agent_list = []
    for i, agent in enumerate(agents):
        agent_name = agent.get("name", "")
        if not agent_name:
            return {"error": f"Agent at index {i} is missing required 'name' field"}

        agent_description = agent.get("description", "")
        if not agent_description:
            return {"error": f"Agent '{agent_name}' is missing required 'description' field"}

        has_endpoint = bool(agent.get("endpoint_name"))
        has_genie = bool(agent.get("genie_space_id"))
        has_ka = bool(agent.get("ka_tile_id"))

        # Count how many agent types are specified
        agent_type_count = sum([has_endpoint, has_genie, has_ka])
        if agent_type_count > 1:
            return {
                "error": f"""Agent '{agent_name}' has multiple agent types. 
                Provide only one of: 'endpoint_name', 'genie_space_id', or 'ka_tile_id'."""
            }
        if agent_type_count == 0:
            return {
                "error": f"Agent '{agent_name}' must have one of: 'endpoint_name', 'genie_space_id', or 'ka_tile_id'"
            }

        agent_config = {
            "name": agent_name,
            "description": agent_description,
        }

        if has_genie:
            agent_config["agent_type"] = "genie"
            agent_config["genie_space"] = {"id": agent.get("genie_space_id")}
        elif has_ka:
            # KA tiles are referenced via their serving endpoint
            # Endpoint name uses the first segment of the tile_id
            ka_tile_id = agent.get("ka_tile_id")
            tile_id_prefix = ka_tile_id.split("-")[0]
            agent_config["agent_type"] = "serving_endpoint"
            agent_config["serving_endpoint"] = {"name": f"ka-{tile_id_prefix}-endpoint"}
        else:
            agent_config["agent_type"] = "serving_endpoint"
            agent_config["serving_endpoint"] = {"name": agent.get("endpoint_name")}

        agent_list.append(agent_config)

    operation = "created"
    response_tile_id = tile_id

    if tile_id:
        # Check if exists
        existing = manager.mas_get(tile_id)
        if existing:
            operation = "updated"
            result = manager.mas_update(
                tile_id=tile_id,
                name=name,
                description=description,
                instructions=instructions,
                agents=agent_list,
            )
        else:
            return {"error": f"MAS {tile_id} not found"}
    else:
        # Check if exists by name
        existing = manager.mas_find_by_name(name)
        if existing:
            operation = "updated"
            response_tile_id = existing.tile_id
            result = manager.mas_update(
                tile_id=existing.tile_id,
                name=name,
                description=description,
                instructions=instructions,
                agents=agent_list,
            )
        else:
            # Create new
            result = manager.mas_create(
                name=name,
                agents=agent_list,
                description=description,
                instructions=instructions,
            )
            response_tile_id = result.get("multi_agent_supervisor", {}).get("tile", {}).get("tile_id", "")

    # Extract status
    mas_data = result.get("multi_agent_supervisor", {})
    tile_data = mas_data.get("tile", {})
    status_data = mas_data.get("status", {})
    endpoint_status = status_data.get("endpoint_status", "UNKNOWN")

    response = {
        "tile_id": response_tile_id or tile_data.get("tile_id", ""),
        "name": tile_data.get("name", name),
        "operation": operation,
        "endpoint_status": endpoint_status,
        "agents_count": len(agents),
    }

    # Add examples if provided
    if examples and response["tile_id"]:
        if endpoint_status == EndpointStatus.ONLINE.value:
            created = manager.mas_add_examples_batch(response["tile_id"], examples)
            response["examples_added"] = len(created)
        else:
            # Queue examples for when endpoint becomes ready
            queue = get_tile_example_queue()
            queue.enqueue(response["tile_id"], manager, examples, tile_type="MAS")
            response["examples_queued"] = len(examples)

    # Track resource on successful create/update
    try:
        mas_tile_id = response.get("tile_id")
        if mas_tile_id:
            from ..manifest import track_resource

            track_resource(
                resource_type="multi_agent_supervisor",
                name=response.get("name", name),
                resource_id=mas_tile_id,
            )
    except Exception:
        pass  # best-effort tracking

    return response


@mcp.tool
def get_mas(tile_id: str) -> Dict[str, Any]:
    """
    Get a Multi-Agent Supervisor by tile ID.

    Args:
        tile_id: The MAS tile ID

    Returns:
        Dictionary with MAS details including:
        - tile_id: The tile ID
        - name: The MAS name
        - description: The description
        - endpoint_status: Current status (ONLINE, PROVISIONING, etc.)
        - agents: List of configured agents
        - examples_count: Number of example questions

    Example:
        >>> get_mas("01xyz...")
        {
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "endpoint_status": "ONLINE",
            "agents": [...],
            "examples_count": 3
        }
    """
    manager = _get_manager()
    result = manager.mas_get(tile_id)

    if not result:
        return {"error": f"Multi-Agent Supervisor {tile_id} not found"}

    mas_data = result.get("multi_agent_supervisor", {})
    tile_data = mas_data.get("tile", {})
    status_data = mas_data.get("status", {})

    # Get examples count
    examples_response = manager.mas_list_examples(tile_id)
    examples_count = len(examples_response.get("examples", []))

    return {
        "tile_id": tile_data.get("tile_id", tile_id),
        "name": tile_data.get("name", ""),
        "description": tile_data.get("description", ""),
        "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
        "agents": mas_data.get("agents", []),
        "examples_count": examples_count,
        "instructions": mas_data.get("instructions", ""),
    }


@mcp.tool
def find_mas_by_name(name: str) -> Dict[str, Any]:
    """
    Find a Multi-Agent Supervisor by its name.

    Use this to look up a MAS when you know the name but not the tile_id.

    Args:
        name: The name of the MAS to find (exact match)

    Returns:
        Dictionary with:
        - found: True if a matching MAS was found
        - tile_id: The tile ID (if found)
        - name: The MAS name (if found)
        - endpoint_status: Current status (if found)
        - agents_count: Number of configured agents (if found)

    Example:
        >>> find_mas_by_name("Customer_Support_MAS")
        {
            "found": True,
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "endpoint_status": "ONLINE",
            "agents_count": 3
        }
    """
    manager = _get_manager()
    result = manager.mas_find_by_name(name)

    if result is None:
        return {"found": False, "name": name}

    # Fetch full details to get endpoint status and agents
    full_details = manager.mas_get(result.tile_id)
    if full_details:
        mas_data = full_details.get("multi_agent_supervisor", {})
        status_data = mas_data.get("status", {})
        return {
            "found": True,
            "tile_id": result.tile_id,
            "name": result.name,
            "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
            "agents_count": len(mas_data.get("agents", [])),
        }

    return {
        "found": True,
        "tile_id": result.tile_id,
        "name": result.name,
        "endpoint_status": "UNKNOWN",
        "agents_count": 0,
    }


@mcp.tool
def delete_mas(tile_id: str) -> Dict[str, Any]:
    """
    Delete a Multi-Agent Supervisor.

    Args:
        tile_id: The MAS tile ID to delete

    Returns:
        Dictionary with:
        - success: True if deleted
        - tile_id: The deleted tile ID

    Example:
        >>> delete_mas("01xyz...")
        {"success": True, "tile_id": "01xyz..."}
    """
    manager = _get_manager()
    try:
        manager.delete(tile_id)
        try:
            from ..manifest import remove_resource

            remove_resource(resource_type="multi_agent_supervisor", resource_id=tile_id)
        except Exception:
            pass
        return {"success": True, "tile_id": tile_id}
    except Exception as e:
        return {"success": False, "tile_id": tile_id, "error": str(e)}
