"""Agent Bricks tools - Manage KA, Genie, and MAS tiles."""

from typing import Any, Dict, List, Optional

from databricks_tools_core.agent_bricks import (
    AgentBricksManager,
    EndpointStatus,
    get_tile_example_queue,
)

from ..server import mcp

# Singleton manager instance
_manager: Optional[AgentBricksManager] = None


def _get_manager() -> AgentBricksManager:
    """Get or create the singleton AgentBricksManager instance."""
    global _manager
    if _manager is None:
        _manager = AgentBricksManager()
    return _manager


# ============================================================================
# Knowledge Assistant (KA) Tools
# ============================================================================


@mcp.tool
def create_or_update_ka(
    name: str,
    volume_path: str,
    description: Optional[str] = None,
    instructions: Optional[str] = None,
    tile_id: Optional[str] = None,
    add_examples_from_volume: bool = True,
) -> Dict[str, Any]:
    """
    Create or update a Knowledge Assistant (KA) with document knowledge sources.

    A Knowledge Assistant is a document-based Q&A system that uses RAG to answer
    questions from indexed documents (PDFs, text files, etc.).

    Args:
        name: Name for the KA (will be sanitized for Databricks naming rules)
        volume_path: Path to the volume folder containing documents
            (e.g., "/Volumes/catalog/schema/volume/folder")
        description: Optional description of what the KA does
        instructions: Optional instructions for how the KA should answer
        tile_id: Optional existing tile_id to update instead of create
        add_examples_from_volume: If True, scan the volume for JSON files
            containing question/guideline pairs and add them as examples.
            These are typically generated by the PDF generation tool.

    Returns:
        Dictionary with:
        - tile_id: The KA tile ID
        - name: The KA name
        - operation: 'created' or 'updated'
        - endpoint_status: Current endpoint status
        - examples_queued: Number of examples queued (if any)

    Example:
        >>> create_or_update_ka(
        ...     name="HR Policy Assistant",
        ...     volume_path="/Volumes/my_catalog/my_schema/raw_data/hr_docs",
        ...     description="Answers questions about HR policies",
        ...     instructions="Be helpful and cite specific policies when answering"
        ... )
        {
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "operation": "created",
            "endpoint_status": "PROVISIONING",
            "examples_queued": 5
        }
    """
    manager = _get_manager()

    # Build knowledge source from volume path
    knowledge_sources = [
        {
            "files_source": {
                "name": f"source_{name.replace(' ', '_').lower()}",
                "type": "files",
                "files": {"path": volume_path},
            }
        }
    ]

    # Create or update the KA
    result = manager.ka_create_or_update(
        name=name,
        knowledge_sources=knowledge_sources,
        description=description,
        instructions=instructions,
        tile_id=tile_id,
    )

    # Extract tile info
    ka_data = result.get("knowledge_assistant", {})
    tile_data = ka_data.get("tile", {})
    status_data = ka_data.get("status", {})

    response_tile_id = tile_data.get("tile_id", "")
    endpoint_status = status_data.get("endpoint_status", "UNKNOWN")

    response = {
        "tile_id": response_tile_id,
        "name": tile_data.get("name", name),
        "operation": result.get("operation", "created"),
        "endpoint_status": endpoint_status,
        "examples_queued": 0,
    }

    # Scan volume for examples if requested
    if add_examples_from_volume and response_tile_id:
        examples = manager.scan_volume_for_examples(volume_path)
        if examples:
            # If endpoint is ONLINE, add examples directly
            if endpoint_status == EndpointStatus.ONLINE.value:
                created = manager.ka_add_examples_batch(response_tile_id, examples)
                response["examples_added"] = len(created)
            else:
                # Queue examples for when endpoint becomes ready
                queue = get_tile_example_queue()
                queue.enqueue(response_tile_id, manager, examples, tile_type="KA")
                response["examples_queued"] = len(examples)

    return response


@mcp.tool
def get_ka(tile_id: str) -> Dict[str, Any]:
    """
    Get a Knowledge Assistant by tile ID.

    Args:
        tile_id: The KA tile ID

    Returns:
        Dictionary with KA details including:
        - tile_id: The tile ID
        - name: The KA name
        - description: The description
        - endpoint_status: Current status (ONLINE, PROVISIONING, etc.)
        - knowledge_sources: List of configured sources
        - examples_count: Number of example questions

    Example:
        >>> get_ka("01abc...")
        {
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "endpoint_status": "ONLINE",
            "knowledge_sources": [...],
            "examples_count": 5
        }
    """
    manager = _get_manager()
    result = manager.ka_get(tile_id)

    if not result:
        return {"error": f"Knowledge Assistant {tile_id} not found"}

    ka_data = result.get("knowledge_assistant", {})
    tile_data = ka_data.get("tile", {})
    status_data = ka_data.get("status", {})

    # Get examples count
    examples_response = manager.ka_list_examples(tile_id)
    examples_count = len(examples_response.get("examples", []))

    return {
        "tile_id": tile_data.get("tile_id", tile_id),
        "name": tile_data.get("name", ""),
        "description": tile_data.get("description", ""),
        "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
        "knowledge_sources": ka_data.get("knowledge_sources", []),
        "examples_count": examples_count,
        "instructions": ka_data.get("instructions", ""),
    }


@mcp.tool
def find_ka_by_name(name: str) -> Dict[str, Any]:
    """
    Find a Knowledge Assistant by its name.

    Use this to look up a KA when you know the name but not the tile_id.
    This is useful when referencing an existing KA in a Multi-Agent Supervisor.

    Args:
        name: The name of the Knowledge Assistant to find (exact match)

    Returns:
        Dictionary with:
        - found: True if a matching KA was found
        - tile_id: The tile ID (if found)
        - name: The KA name (if found)
        - endpoint_name: The model serving endpoint name (if found)
        - endpoint_status: Current status (if found)

    Example:
        >>> find_ka_by_name("HR_Policy_Assistant")
        {
            "found": True,
            "tile_id": "01abc...",
            "name": "HR_Policy_Assistant",
            "endpoint_name": "ka-01abc...-endpoint",
            "endpoint_status": "ONLINE"
        }
    """
    manager = _get_manager()
    result = manager.find_by_name(name)

    if result is None:
        return {"found": False, "name": name}

    # Fetch full details to get endpoint status
    full_details = manager.ka_get(result.tile_id)
    endpoint_status = "UNKNOWN"
    if full_details:
        endpoint_status = (
            full_details.get("knowledge_assistant", {})
            .get("status", {})
            .get("endpoint_status", "UNKNOWN")
        )

    # Endpoint name uses only the first segment of the tile_id (before the first hyphen)
    tile_id_prefix = result.tile_id.split("-")[0]
    return {
        "found": True,
        "tile_id": result.tile_id,
        "name": result.name,
        "endpoint_name": f"ka-{tile_id_prefix}-endpoint",
        "endpoint_status": endpoint_status,
    }


@mcp.tool
def delete_ka(tile_id: str) -> Dict[str, Any]:
    """
    Delete a Knowledge Assistant.

    Args:
        tile_id: The KA tile ID to delete

    Returns:
        Dictionary with:
        - success: True if deleted
        - tile_id: The deleted tile ID

    Example:
        >>> delete_ka("01abc...")
        {"success": True, "tile_id": "01abc..."}
    """
    manager = _get_manager()
    try:
        manager.delete(tile_id)
        return {"success": True, "tile_id": tile_id}
    except Exception as e:
        return {"success": False, "tile_id": tile_id, "error": str(e)}


# ============================================================================
# Genie Space Tools
# ============================================================================


@mcp.tool
def create_or_update_genie(
    display_name: str,
    table_identifiers: List[str],
    warehouse_id: Optional[str] = None,
    description: Optional[str] = None,
    sample_questions: Optional[List[str]] = None,
    space_id: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Create or update a Genie Space for SQL-based data exploration.

    A Genie Space allows users to ask natural language questions about data
    and get SQL-generated answers. It connects to tables in Unity Catalog.

    Args:
        display_name: Display name for the Genie space
        table_identifiers: List of tables to include
            (e.g., ["catalog.schema.customers", "catalog.schema.orders"])
        warehouse_id: SQL warehouse ID. If not provided, auto-detects the best
            available warehouse (prefers running, smaller warehouses)
        description: Optional description of what the Genie space does
        sample_questions: Optional list of sample questions to help users
        space_id: Optional existing space_id to update instead of create

    Returns:
        Dictionary with:
        - space_id: The Genie space ID
        - display_name: The display name
        - operation: 'created' or 'updated'
        - warehouse_id: The warehouse being used
        - table_count: Number of tables configured

    Example:
        >>> create_or_update_genie(
        ...     display_name="Sales Analytics",
        ...     table_identifiers=[
        ...         "my_catalog.sales.orders",
        ...         "my_catalog.sales.customers"
        ...     ],
        ...     description="Explore sales data with natural language",
        ...     sample_questions=["What were total sales last month?"]
        ... )
        {
            "space_id": "abc123...",
            "display_name": "Sales Analytics",
            "operation": "created",
            "warehouse_id": "def456...",
            "table_count": 2
        }
    """
    manager = _get_manager()

    # Auto-detect warehouse if not provided
    if warehouse_id is None:
        warehouse_id = manager.get_best_warehouse_id()
        if warehouse_id is None:
            return {
                "error": "No SQL warehouses available. Please provide a warehouse_id or create a warehouse."
            }

    operation = "created"

    if space_id:
        # Update existing space
        existing = manager.genie_get(space_id)
        if existing:
            operation = "updated"
            result = manager.genie_update(
                space_id=space_id,
                display_name=display_name,
                description=description,
                warehouse_id=warehouse_id,
                table_identifiers=table_identifiers,
                sample_questions=sample_questions,
            )
        else:
            return {"error": f"Genie space {space_id} not found"}
    else:
        # Check if exists by name first
        existing = manager.genie_find_by_name(display_name)
        if existing:
            operation = "updated"
            result = manager.genie_update(
                space_id=existing.space_id,
                display_name=display_name,
                description=description,
                warehouse_id=warehouse_id,
                table_identifiers=table_identifiers,
                sample_questions=sample_questions,
            )
            space_id = existing.space_id
        else:
            # Create new
            result = manager.genie_create(
                display_name=display_name,
                warehouse_id=warehouse_id,
                table_identifiers=table_identifiers,
                description=description,
            )
            space_id = result.get("space_id", "")

            # Add sample questions if provided
            if sample_questions and space_id:
                manager.genie_add_sample_questions_batch(space_id, sample_questions)

    return {
        "space_id": space_id or result.get("space_id", ""),
        "display_name": display_name,
        "operation": operation,
        "warehouse_id": warehouse_id,
        "table_count": len(table_identifiers),
    }


@mcp.tool
def get_genie(space_id: str) -> Dict[str, Any]:
    """
    Get a Genie Space by ID.

    Args:
        space_id: The Genie space ID

    Returns:
        Dictionary with Genie space details including:
        - space_id: The space ID
        - display_name: The display name
        - description: The description
        - warehouse_id: The SQL warehouse ID
        - table_identifiers: List of configured tables
        - sample_questions: List of sample questions

    Example:
        >>> get_genie("abc123...")
        {
            "space_id": "abc123...",
            "display_name": "Sales Analytics",
            "warehouse_id": "def456...",
            "table_identifiers": ["catalog.schema.orders"],
            "sample_questions": ["What were total sales?"]
        }
    """
    manager = _get_manager()
    result = manager.genie_get(space_id)

    if not result:
        return {"error": f"Genie space {space_id} not found"}

    # Get sample questions
    questions_response = manager.genie_list_questions(space_id, question_type="SAMPLE_QUESTION")
    sample_questions = [
        q.get("question_text", "") for q in questions_response.get("curated_questions", [])
    ]

    return {
        "space_id": result.get("space_id", space_id),
        "display_name": result.get("display_name", ""),
        "description": result.get("description", ""),
        "warehouse_id": result.get("warehouse_id", ""),
        "table_identifiers": result.get("table_identifiers", []),
        "sample_questions": sample_questions,
    }


@mcp.tool
def find_genie_by_name(display_name: str) -> Dict[str, Any]:
    """
    Find a Genie Space by its display name.

    Use this to look up a Genie space when you know the name but not the space_id.
    This is useful when referencing an existing Genie space in a Multi-Agent Supervisor.

    Note: There is no system table for Genie spaces. Use this tool instead of
    trying to query system.ai.genie_spaces or similar (which don't exist).

    Args:
        display_name: The display name of the Genie space to find (exact match)

    Returns:
        Dictionary with:
        - found: True if a matching space was found
        - space_id: The space ID (if found)
        - display_name: The display name (if found)
        - description: The description (if found)
        - warehouse_id: The warehouse ID (if found)

    Example:
        >>> find_genie_by_name("Sales Analytics")
        {
            "found": True,
            "space_id": "abc123...",
            "display_name": "Sales Analytics",
            "warehouse_id": "def456..."
        }
    """
    manager = _get_manager()
    result = manager.genie_find_by_name(display_name)

    if result is None:
        return {"found": False, "display_name": display_name}

    # Fetch full details to get description and warehouse_id
    full_details = manager.genie_get(result.space_id)
    if full_details:
        return {
            "found": True,
            "space_id": result.space_id,
            "display_name": result.display_name,
            "description": full_details.get("description", ""),
            "warehouse_id": full_details.get("warehouse_id", ""),
            "table_identifiers": full_details.get("table_identifiers", []),
        }

    return {
        "found": True,
        "space_id": result.space_id,
        "display_name": result.display_name,
        "description": "",
        "warehouse_id": "",
    }


@mcp.tool
def delete_genie(space_id: str) -> Dict[str, Any]:
    """
    Delete a Genie Space.

    Args:
        space_id: The Genie space ID to delete

    Returns:
        Dictionary with:
        - success: True if deleted
        - space_id: The deleted space ID

    Example:
        >>> delete_genie("abc123...")
        {"success": True, "space_id": "abc123..."}
    """
    manager = _get_manager()
    try:
        manager.genie_delete(space_id)
        return {"success": True, "space_id": space_id}
    except Exception as e:
        return {"success": False, "space_id": space_id, "error": str(e)}


# ============================================================================
# Multi-Agent Supervisor (MAS) Tools
# ============================================================================


@mcp.tool
def create_or_update_mas(
    name: str,
    agents: List[Dict[str, str]],
    description: Optional[str] = None,
    instructions: Optional[str] = None,
    tile_id: Optional[str] = None,
    examples: Optional[List[Dict[str, str]]] = None,
) -> Dict[str, Any]:
    """
    Create or update a Multi-Agent Supervisor (MAS).

    A MAS orchestrates multiple agents, routing user queries to the appropriate
    specialized agent based on the query content. Supports both model serving
    endpoints and Genie spaces as agents.

    Args:
        name: Name for the MAS (will be sanitized for Databricks naming rules)
        agents: List of agent configurations. Each agent requires:
            - name: Agent identifier (used internally for routing)
            - description: What this agent handles (critical for routing decisions)
            - endpoint_name: Model serving endpoint name (for custom agents)
            - genie_space_id: Genie space ID (for SQL-based data agents)
            - ka_tile_id: Knowledge Assistant tile ID (for document Q&A agents)
            Note: Provide exactly one of: endpoint_name, genie_space_id, or ka_tile_id.
        description: Optional description of what the MAS does
        instructions: Optional routing instructions for the supervisor
        tile_id: Optional existing tile_id to update instead of create
        examples: Optional list of example questions, each with:
            - question: The example question
            - guideline: Expected routing behavior or answer guidelines

    Returns:
        Dictionary with:
        - tile_id: The MAS tile ID
        - name: The MAS name
        - operation: 'created' or 'updated'
        - endpoint_status: Current endpoint status
        - agents_count: Number of configured agents

    Example:
        >>> # Mix of Knowledge Assistants, Genie spaces, and custom endpoints
        >>> create_or_update_mas(
        ...     name="Customer Support MAS",
        ...     agents=[
        ...         {
        ...             "name": "policy_agent",
        ...             "ka_tile_id": "f32c5f73-466b-...",
        ...             "description": "Answers questions about company policies and procedures"
        ...         },
        ...         {
        ...             "name": "analytics_agent",
        ...             "genie_space_id": "01abc123...",
        ...             "description": "Answers data questions about usage and metrics"
        ...         },
        ...         {
        ...             "name": "custom_agent",
        ...             "endpoint_name": "my-custom-endpoint",
        ...             "description": "Handles specialized queries via custom agent"
        ...         }
        ...     ],
        ...     description="Routes customer queries to specialized agents",
        ...     instructions="Route policy questions to policy_agent, data questions to analytics_agent."
        ... )
        {
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "operation": "created",
            "endpoint_status": "PROVISIONING",
            "agents_count": 3
        }
    """
    manager = _get_manager()

    # Validate and build agent list for API
    agent_list = []
    for i, agent in enumerate(agents):
        agent_name = agent.get("name", "")
        if not agent_name:
            return {"error": f"Agent at index {i} is missing required 'name' field"}

        agent_description = agent.get("description", "")
        if not agent_description:
            return {"error": f"Agent '{agent_name}' is missing required 'description' field"}

        has_endpoint = bool(agent.get("endpoint_name"))
        has_genie = bool(agent.get("genie_space_id"))
        has_ka = bool(agent.get("ka_tile_id"))

        # Count how many agent types are specified
        agent_type_count = sum([has_endpoint, has_genie, has_ka])
        if agent_type_count > 1:
            return {
                "error": f"Agent '{agent_name}' has multiple agent types. Provide only one of: 'endpoint_name', 'genie_space_id', or 'ka_tile_id'."
            }
        if agent_type_count == 0:
            return {
                "error": f"Agent '{agent_name}' must have one of: 'endpoint_name', 'genie_space_id', or 'ka_tile_id'"
            }

        agent_config = {
            "name": agent_name,
            "description": agent_description,
        }

        if has_genie:
            agent_config["agent_type"] = "genie"
            agent_config["genie_space"] = {"id": agent.get("genie_space_id")}
        elif has_ka:
            # KA tiles are referenced via their serving endpoint
            # Endpoint name uses the first segment of the tile_id
            ka_tile_id = agent.get("ka_tile_id")
            tile_id_prefix = ka_tile_id.split("-")[0]
            agent_config["agent_type"] = "serving_endpoint"
            agent_config["serving_endpoint"] = {"name": f"ka-{tile_id_prefix}-endpoint"}
        else:
            agent_config["agent_type"] = "serving_endpoint"
            agent_config["serving_endpoint"] = {"name": agent.get("endpoint_name")}

        agent_list.append(agent_config)

    operation = "created"
    response_tile_id = tile_id

    if tile_id:
        # Check if exists
        existing = manager.mas_get(tile_id)
        if existing:
            operation = "updated"
            result = manager.mas_update(
                tile_id=tile_id,
                name=name,
                description=description,
                instructions=instructions,
                agents=agent_list,
            )
        else:
            return {"error": f"MAS {tile_id} not found"}
    else:
        # Check if exists by name
        existing = manager.mas_find_by_name(name)
        if existing:
            operation = "updated"
            response_tile_id = existing.tile_id
            result = manager.mas_update(
                tile_id=existing.tile_id,
                name=name,
                description=description,
                instructions=instructions,
                agents=agent_list,
            )
        else:
            # Create new
            result = manager.mas_create(
                name=name,
                agents=agent_list,
                description=description,
                instructions=instructions,
            )
            response_tile_id = (
                result.get("multi_agent_supervisor", {}).get("tile", {}).get("tile_id", "")
            )

    # Extract status
    mas_data = result.get("multi_agent_supervisor", {})
    tile_data = mas_data.get("tile", {})
    status_data = mas_data.get("status", {})
    endpoint_status = status_data.get("endpoint_status", "UNKNOWN")

    response = {
        "tile_id": response_tile_id or tile_data.get("tile_id", ""),
        "name": tile_data.get("name", name),
        "operation": operation,
        "endpoint_status": endpoint_status,
        "agents_count": len(agents),
    }

    # Add examples if provided
    if examples and response["tile_id"]:
        if endpoint_status == EndpointStatus.ONLINE.value:
            created = manager.mas_add_examples_batch(response["tile_id"], examples)
            response["examples_added"] = len(created)
        else:
            # Queue examples for when endpoint becomes ready
            queue = get_tile_example_queue()
            queue.enqueue(response["tile_id"], manager, examples, tile_type="MAS")
            response["examples_queued"] = len(examples)

    return response


@mcp.tool
def get_mas(tile_id: str) -> Dict[str, Any]:
    """
    Get a Multi-Agent Supervisor by tile ID.

    Args:
        tile_id: The MAS tile ID

    Returns:
        Dictionary with MAS details including:
        - tile_id: The tile ID
        - name: The MAS name
        - description: The description
        - endpoint_status: Current status (ONLINE, PROVISIONING, etc.)
        - agents: List of configured agents
        - examples_count: Number of example questions

    Example:
        >>> get_mas("01xyz...")
        {
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "endpoint_status": "ONLINE",
            "agents": [...],
            "examples_count": 3
        }
    """
    manager = _get_manager()
    result = manager.mas_get(tile_id)

    if not result:
        return {"error": f"Multi-Agent Supervisor {tile_id} not found"}

    mas_data = result.get("multi_agent_supervisor", {})
    tile_data = mas_data.get("tile", {})
    status_data = mas_data.get("status", {})

    # Get examples count
    examples_response = manager.mas_list_examples(tile_id)
    examples_count = len(examples_response.get("examples", []))

    return {
        "tile_id": tile_data.get("tile_id", tile_id),
        "name": tile_data.get("name", ""),
        "description": tile_data.get("description", ""),
        "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
        "agents": mas_data.get("agents", []),
        "examples_count": examples_count,
        "instructions": mas_data.get("instructions", ""),
    }


@mcp.tool
def find_mas_by_name(name: str) -> Dict[str, Any]:
    """
    Find a Multi-Agent Supervisor by its name.

    Use this to look up a MAS when you know the name but not the tile_id.

    Args:
        name: The name of the MAS to find (exact match)

    Returns:
        Dictionary with:
        - found: True if a matching MAS was found
        - tile_id: The tile ID (if found)
        - name: The MAS name (if found)
        - endpoint_status: Current status (if found)
        - agents_count: Number of configured agents (if found)

    Example:
        >>> find_mas_by_name("Customer_Support_MAS")
        {
            "found": True,
            "tile_id": "01xyz...",
            "name": "Customer_Support_MAS",
            "endpoint_status": "ONLINE",
            "agents_count": 3
        }
    """
    manager = _get_manager()
    result = manager.mas_find_by_name(name)

    if result is None:
        return {"found": False, "name": name}

    # Fetch full details to get endpoint status and agents
    full_details = manager.mas_get(result.tile_id)
    if full_details:
        mas_data = full_details.get("multi_agent_supervisor", {})
        status_data = mas_data.get("status", {})
        return {
            "found": True,
            "tile_id": result.tile_id,
            "name": result.name,
            "endpoint_status": status_data.get("endpoint_status", "UNKNOWN"),
            "agents_count": len(mas_data.get("agents", [])),
        }

    return {
        "found": True,
        "tile_id": result.tile_id,
        "name": result.name,
        "endpoint_status": "UNKNOWN",
        "agents_count": 0,
    }


@mcp.tool
def delete_mas(tile_id: str) -> Dict[str, Any]:
    """
    Delete a Multi-Agent Supervisor.

    Args:
        tile_id: The MAS tile ID to delete

    Returns:
        Dictionary with:
        - success: True if deleted
        - tile_id: The deleted tile ID

    Example:
        >>> delete_mas("01xyz...")
        {"success": True, "tile_id": "01xyz..."}
    """
    manager = _get_manager()
    try:
        manager.delete(tile_id)
        return {"success": True, "tile_id": tile_id}
    except Exception as e:
        return {"success": False, "tile_id": tile_id, "error": str(e)}
